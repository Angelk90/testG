{"version":3,"sources":["translatorLanguage.tsx","App.tsx","index.tsx"],"names":["translate","text","opts","a","pronunciation","from","language","didYouMean","iso","autoCorrected","value","raw","key","res","result","RegExp","exec","replace","slice","obj","keyValuePairs","push","join","to","tld","url","console","log","fetch","response","txt","undefined","doubleTranslate","str","Promise","all","App","fetchData","useCallback","translations","useEffect","className","rootElement","document","getElementById","render"],"mappings":"oLAEeA,E,gFAAf,WACEC,EACAC,GAFF,mBAAAC,EAAA,sEAKiB,CACXF,KAAM,GACNG,cAAe,GACfC,KAAM,CACJC,SAAU,CACRC,YAAY,EACZC,IAAK,IAEPP,KAAM,CACJQ,eAAe,EACfC,MAAO,GACPH,YAAY,IAGhBI,IAAK,IAiBS,SAACC,EAAaC,GAC5B,IACIC,EADK,IAAIC,OAAJ,WAAeH,EAAf,YACOI,KAAKH,GACrB,OAAe,OAAXC,EACKA,EAAO,GAAGG,QAAV,WAAsBL,EAAtB,OAAgC,IAAIM,MAAM,GAAI,GAEhD,IAGgB,SAACC,GACxB,IAAMC,EAAgB,GACtB,IAAK,IAAMR,KAAOO,EAChBC,EAAcC,KAAKT,EAAM,IAAMO,EAAIP,IAErC,OAAOQ,EAAcE,KAAK,OA5B5BpB,EAAOA,GAAQ,IA+BVG,KAAOH,EAAKG,MAAQ,OACzBH,EAAKqB,GAAKrB,EAAKqB,IAAM,KACrBrB,EAAKsB,IAAMtB,EAAKsB,KAAO,MAKnBC,EAAM,4BAA8BvB,EAAKsB,IAC7CE,QAAQC,IAAI,QA7DhB,UA8DyBC,MAAMH,GA9D/B,eA8DQI,EA9DR,iBA+DoBA,EAAS5B,OA/D7B,eA+DQ6B,EA/DR,OAgEIJ,QAAQC,IAAI,MAAOG,GAhEvB,kBAkEW,CAAC,CAAC7B,UAAM8B,GAAW,CAAC9B,UAAM8B,KAlErC,kCA0KIL,QAAQC,IAAR,MA1KJ,sCA6KSI,GA7KT,2D,sBAgLO,SAAeC,EAAtB,kC,4CAAO,WAA+BC,GAA/B,SAAA9B,EAAA,sEACiB+B,QAAQC,IAAI,CAChCnC,EAAUiC,EAAK,CAACV,GAAI,KAAMlB,KAAM,OAChCL,EAAUiC,EAAK,CAACV,GAAI,KAAMlB,KAAM,SAH7B,uCAME,IANF,4C,iCC/KQ,SAAS+B,IACtB,IAAMC,EAAYC,sBAAW,sBAAC,4BAAAnC,EAAA,sEACD6B,EAAgB,kBADf,OACtBO,EADsB,OAE5Bb,QAAQC,IAAIY,GAFgB,2CAG3B,IAMH,OAJAC,qBAAU,WACRH,MACC,IAGD,qBAAKI,UAAU,MAAf,SACE,uCCXN,IAAMC,EAAcC,SAASC,eAAe,QAC5CC,iBAAO,cAACT,EAAD,IAASM,K","file":"static/js/main.cd7fadba.chunk.js","sourcesContent":["// import translatorLanguage from './translatorLanguage'\n\nasync function translate(\n  text: string,\n  opts?: {from?: string | boolean; to?: string | boolean; tld?: string},\n) {\n  try {\n    var result = {\n      text: '',\n      pronunciation: '',\n      from: {\n        language: {\n          didYouMean: false,\n          iso: '',\n        },\n        text: {\n          autoCorrected: false,\n          value: '',\n          didYouMean: false,\n        },\n      },\n      raw: '',\n    }\n\n    opts = opts || {}\n    // var e = undefined as {message: string; code: number} | undefined\n    // var languages = new translatorLanguage()\n    // ;[opts.from, opts.to].forEach(function (lang) {\n    //   if (lang && !languages.isSupported(lang)) {\n    //     e = {\n    //       message: \"The language '\" + lang + \"' is not supported\",\n    //       code: 400,\n    //     }\n    //   }\n    // })\n    // if (e) {\n    //   return undefined\n    // }\n    const extract = (key: string, res: string) => {\n      var re = new RegExp(`\"${key}\":\".*?\"`)\n      var result = re.exec(res)\n      if (result !== null) {\n        return result[0].replace(`\"${key}\":\"`, '').slice(0, -1)\n      }\n      return ''\n    }\n\n    const objToQueryString = (obj: any) => {\n      const keyValuePairs = []\n      for (const key in obj) {\n        keyValuePairs.push(key + '=' + obj[key])\n      }\n      return keyValuePairs.join('&')\n    }\n\n    opts.from = opts.from || 'auto'\n    opts.to = opts.to || 'en'\n    opts.tld = opts.tld || 'com'\n\n    // opts.from = languages.getCode(opts.from.toString())\n    // opts.to = languages.getCode(opts.to.toString())\n\n    var url = 'https://translate.google.' + opts.tld\n    console.log(\"body\")\n    var response = await fetch(url)\n    var txt = await response.text()\n    console.log(\"txt\", txt)\n\n    return [{text: undefined},{text: undefined}]\n\n\n    /* var data = {\n      rpcids: 'MkEWBc',\n      'f.sid': extract('FdrFJe', txt),\n      bl: extract('cfb2h', txt),\n      hl: 'en-US',\n      'soc-app': 1,\n      'soc-platform': 1,\n      'soc-device': 1,\n      _reqid: Math.floor(1000 + Math.random() * 9000),\n      rt: 'c',\n    }\n\n    console.log(\"body\", opts)\n\n    url =\n      url +\n      '/_/TranslateWebserverUi/data/batchexecute?' +\n      objToQueryString(data)\n    var body =\n      'f.req=' +\n      encodeURIComponent(\n        JSON.stringify([\n          [\n            [\n              'MkEWBc',\n              JSON.stringify([[text, opts.from, opts.to, true], [null]]),\n              null,\n              'generic',\n            ],\n          ],\n        ]),\n      ) +\n      '&'\n    var res = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',\n      },\n      body: body,\n    })\n    if (res) {\n      console.log(\"--\", res)\n      var ttx = await res.text()\n      var json = ttx.slice(6)\n      var length = ''\n\n      try {\n        length = /^\\d+/.exec(json)![0]\n\n        json = JSON.parse(\n          json.slice(length.length, parseInt(length, 10) + length.length),\n        )\n\n        json = JSON.parse(json[0][2])\n\n        result.raw = json\n      } catch (e) {\n        return result\n      }\n      if (json[1][0][0][5] === undefined) {\n        // translation not found, could be a hyperlink?\n        result.text = json[1][0][0][0]\n      } else {\n        ;(json[1][0][0][5] as any).forEach(function (obj: any) {\n          if (obj[0]) {\n            result.text += obj[0]\n          }\n        })\n      }\n      result.pronunciation = json[1][0][0][1]\n\n      // From language\n      if (json[0] && json[0][1] && json[0][1][1]) {\n        result.from.language.didYouMean = true\n        result.from.language.iso = json[0][1][1][0]\n      } else if (json[1][3] === 'auto') {\n        result.from.language.iso = json[2]\n      } else {\n        result.from.language.iso = json[1][3]\n      }\n\n      // Did you mean & autocorrect\n      if (json[0] && json[0][1] && json[0][1][0]) {\n        var str = json[0][1][0][0][1]\n\n        str = str.replace(/<b>(<i>)?/g, '[')\n        str = str.replace(/(<\\/i>)?<\\/b>/g, ']')\n\n        result.from.text.value = str\n\n        // @ts-ignore\n        if (json[0][1][0][2] === 1) {\n          result.from.text.autoCorrected = true\n        } else {\n          result.from.text.didYouMean = true\n        }\n      }\n\n      return result\n    }*/\n  } catch (error) {\n    console.log(error)\n  }\n\n  return undefined\n}\n\nexport async function doubleTranslate(str: string) {\n  const results = await Promise.all([\n    translate(str, {to: 'en', from: 'it'}),\n    translate(str, {to: 'it', from: 'en'}),\n  ])\n\n  return {\n    //en: results[0]?.text,\n    //it: results[1]?.text,\n  }\n}\n","import React, { useEffect, useCallback } from \"react\";\nimport { doubleTranslate } from \"./translatorLanguage\";\n\nexport default function App() {\n  const fetchData = useCallback(async () => {\n    const translations = await doubleTranslate(\"Hi, my name is\");\n    console.log(translations);\n  }, []);\n\n  useEffect(() => {\n    fetchData();\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <h1>Hi!</h1>\n    </div>\n  );\n}\n","import { render } from \"react-dom\";\n\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\nrender(<App />, rootElement);\n"],"sourceRoot":""}